# 校园购物商城详细设计文档

## 1. 文档概述

### 1.1 文档目的
本文档基于校园购物商城的需求说明书和概要设计文档，详细描述系统的具体实现细节，包括类设计、接口实现、流程设计、安全性设计等内容，为开发团队提供具体的开发指导。

### 1.2 术语定义
- **API**：应用程序编程接口
- **DTO**：数据传输对象（Data Transfer Object）
- **VO**：视图对象（View Object）
- **POJO**：普通Java对象（Plain Old Java Object）
- **JWT**：JSON Web Token，用于用户身份认证
- **CORS**：跨域资源共享（Cross-Origin Resource Sharing）
- **AOP**：面向切面编程（Aspect-Oriented Programming）
- **ORM**：对象关系映射（Object-Relational Mapping）

## 2. 系统架构详细设计

### 2.1 前端架构详细设计

#### 2.1.1 前端项目结构
```
frontend/
├── public/                 # 静态资源
├── src/                    # 源代码
│   ├── assets/             # 项目资源文件
│   │   ├── images/         # 图片资源
│   │   └── styles/         # 样式文件
│   ├── components/         # 公共组件
│   │   ├── common/         # 通用组件
│   │   └── business/       # 业务组件
│   ├── views/              # 页面组件
│   │   ├── user/           # 用户相关页面
│   │   ├── product/        # 商品相关页面
│   │   ├── cart/           # 购物车相关页面
│   │   ├── order/          # 订单相关页面
│   │   └── admin/          # 管理员相关页面
│   ├── router/             # 路由配置
│   ├── store/              # 状态管理
│   ├── api/                # API请求封装
│   ├── utils/              # 工具函数
│   ├── services/           # 业务逻辑服务
│   ├── constants/          # 常量定义
│   ├── App.vue             # 应用主组件
│   └── main.js             # 应用入口文件
├── tests/                  # 测试文件
├── .eslintrc.js            # ESLint配置
├── .prettierrc.js          # Prettier配置
├── babel.config.js         # Babel配置
├── vue.config.js           # Vue配置
├── package.json            # 项目配置和依赖
└── README.md               # 项目说明文档
```

#### 2.1.2 前端组件分层

1. **基础组件层**：提供基础UI组件，如按钮、表单、弹窗等，基于Element Plus二次封装
2. **业务组件层**：封装特定业务场景的组件，如商品卡片、订单列表项、用户信息展示等
3. **页面组件层**：由多个组件组合而成的完整页面

#### 2.1.3 前端状态管理设计

使用Pinia进行状态管理，主要包含以下Store：

1. **UserStore**：管理用户信息和认证状态
2. **ProductStore**：管理商品列表、商品详情等状态
3. **CartStore**：管理购物车状态
4. **OrderStore**：管理订单状态
5. **AppStore**：管理应用全局状态，如主题、语言等

#### 2.1.4 前端路由设计

```javascript
// 路由配置示例
const routes = [
  // 公共路由
  {
    path: '/',
    name: 'Home',
    component: () => import('@/views/Home.vue')
  },
  {
    path: '/login',
    name: 'Login',
    component: () => import('@/views/user/Login.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/register',
    name: 'Register',
    component: () => import('@/views/user/Register.vue'),
    meta: { requiresAuth: false }
  },
  {
    path: '/products/:id',
    name: 'ProductDetail',
    component: () => import('@/views/product/ProductDetail.vue')
  },
  
  // 需要认证的路由
  {
    path: '/user',
    component: () => import('@/views/user/UserLayout.vue'),
    meta: { requiresAuth: true },
    children: [
      {
        path: 'profile',
        name: 'UserProfile',
        component: () => import('@/views/user/Profile.vue')
      },
      {
        path: 'addresses',
        name: 'UserAddresses',
        component: () => import('@/views/user/Addresses.vue')
      },
      {
        path: 'orders',
        name: 'UserOrders',
        component: () => import('@/views/order/UserOrders.vue')
      }
    ]
  },
  
  // 购物车路由
  {
    path: '/cart',
    name: 'Cart',
    component: () => import('@/views/cart/Cart.vue'),
    meta: { requiresAuth: true }
  },
  {
    path: '/checkout',
    name: 'Checkout',
    component: () => import('@/views/cart/Checkout.vue'),
    meta: { requiresAuth: true }
  },
  
  // 管理员路由
  {
    path: '/admin',
    component: () => import('@/views/admin/AdminLayout.vue'),
    meta: { requiresAuth: true, requiresAdmin: true },
    children: [
      {
        path: 'dashboard',
        name: 'AdminDashboard',
        component: () => import('@/views/admin/Dashboard.vue')
      },
      {
        path: 'users',
        name: 'AdminUsers',
        component: () => import('@/views/admin/Users.vue')
      },
      {
        path: 'products',
        name: 'AdminProducts',
        component: () => import('@/views/admin/Products.vue')
      },
      {
        path: 'orders',
        name: 'AdminOrders',
        component: () => import('@/views/admin/Orders.vue')
      }
    ]
  },
  
  // 404路由
  {
    path: '/:pathMatch(.*)*',
    name: 'NotFound',
    component: () => import('@/views/NotFound.vue')
  }
]
```

### 2.2 后端架构详细设计

#### 2.2.1 后端项目结构
```
backend/
├── src/
│   ├── main/
│   │   ├── java/com/shopping/
│   │   │   ├── common/            # 公共模块
│   │   │   │   ├── config/         # 配置类
│   │   │   │   ├── exception/      # 异常处理
│   │   │   │   ├── response/       # 响应工具
│   │   │   │   ├── utils/          # 工具类
│   │   │   │   └── validation/     # 数据校验
│   │   │   ├── user/               # 用户模块
│   │   │   │   ├── controller/     # 控制器
│   │   │   │   ├── service/        # 服务层
│   │   │   │   ├── mapper/         # 数据访问层
│   │   │   │   ├── entity/         # 实体类
│   │   │   │   └── dto/            # 数据传输对象
│   │   │   ├── product/            # 商品模块
│   │   │   ├── cart/               # 购物车模块
│   │   │   ├── order/              # 订单模块
│   │   │   ├── review/             # 评价模块
│   │   │   ├── admin/              # 管理员模块
│   │   │   └── ShoppingApplication.java # 应用入口
│   │   └── resources/
│   │       ├── mapper/             # MyBatis映射文件
│   │       ├── static/             # 静态资源
│   │       ├── templates/          # 模板文件
│   │       ├── application.yml     # 应用配置
│   │       └── application-dev.yml # 开发环境配置
│   └── test/                       # 测试代码
├── pom.xml                         # Maven依赖配置
└── README.md                       # 项目说明
```

#### 2.2.2 后端分层设计

1. **Controller层**：处理HTTP请求，参数校验，响应处理
2. **Service层**：业务逻辑实现，事务管理
3. **Mapper层**：数据库操作，SQL映射
4. **Entity层**：数据库实体映射
5. **DTO层**：数据传输对象，用于前后端数据交换
6. **VO层**：视图对象，用于组装返回给前端的数据

## 3. 核心模块详细设计

### 3.1 用户模块详细设计

#### 3.1.1 接口设计

| API路径 | 方法 | 模块/文件 | 类型 | 功能描述 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/v1/auth/register` | `POST` | `UserController.java` | `Controller` | 用户注册 |
| `/api/v1/auth/login` | `POST` | `UserController.java` | `Controller` | 用户登录 |
| `/api/v1/auth/logout` | `POST` | `UserController.java` | `Controller` | 用户登出 |
| `/api/v1/users/profile` | `GET` | `UserController.java` | `Controller` | 获取用户信息 |
| `/api/v1/users/profile` | `PUT` | `UserController.java` | `Controller` | 更新用户信息 |
| `/api/v1/users/password` | `POST` | `UserController.java` | `Controller` | 修改密码 |

#### 3.1.2 类设计

```java
// 用户实体类
public class User {
    private Long id;
    private String username;
    private String password;
    private String phone;
    private String email;
    private String avatar;
    private String nickname;
    private Integer gender;
    private Date birthday;
    private Integer status;
    private Date createTime;
    private Date updateTime;
    private Date lastLoginTime;
    // getter and setter
}

// 用户注册DTO
public class UserRegisterDTO {
    @NotBlank(message = "用户名不能为空")
    @Size(min = 4, max = 20, message = "用户名长度必须在4-20之间")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    @Size(min = 6, max = 20, message = "密码长度必须在6-20之间")
    private String password;
    
    @NotBlank(message = "手机号不能为空")
    @Pattern(regexp = "^1[3-9]\\d{9}$", message = "手机号格式不正确")
    private String phone;
    
    @Email(message = "邮箱格式不正确")
    private String email;
    // getter and setter
}

// 用户登录DTO
public class UserLoginDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    // getter and setter
}

// 用户服务接口
public interface UserService {
    // 用户注册
    User register(UserRegisterDTO userRegisterDTO);
    
    // 用户登录
    String login(UserLoginDTO userLoginDTO);
    
    // 获取用户信息
    User getUserById(Long userId);
    
    // 更新用户信息
    User updateUser(Long userId, UserUpdateDTO userUpdateDTO);
    
    // 修改密码
    void updatePassword(Long userId, String oldPassword, String newPassword);
}

// 用户服务实现类
@Service
public class UserServiceImpl implements UserService {
    @Autowired
    private UserMapper userMapper;
    
    @Autowired
    private PasswordUtils passwordUtils;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Override
    public User register(UserRegisterDTO userRegisterDTO) {
        // 检查用户名是否已存在
        if (userMapper.existsByUsername(userRegisterDTO.getUsername())) {
            throw new BusinessException("用户名已存在");
        }
        
        // 检查手机号是否已存在
        if (userMapper.existsByPhone(userRegisterDTO.getPhone())) {
            throw new BusinessException("手机号已被注册");
        }
        
        // 创建用户对象
        User user = new User();
        user.setUsername(userRegisterDTO.getUsername());
        // 密码加密
        user.setPassword(passwordUtils.encode(userRegisterDTO.getPassword()));
        user.setPhone(userRegisterDTO.getPhone());
        user.setEmail(userRegisterDTO.getEmail());
        user.setStatus(1); // 启用状态
        
        // 保存用户
        userMapper.insert(user);
        return user;
    }
    
    @Override
    public String login(UserLoginDTO userLoginDTO) {
        // 根据用户名查询用户
        User user = userMapper.selectByUsername(userLoginDTO.getUsername());
        if (user == null) {
            throw new BusinessException("用户名或密码错误");
        }
        
        // 检查密码是否正确
        if (!passwordUtils.matches(userLoginDTO.getPassword(), user.getPassword())) {
            throw new BusinessException("用户名或密码错误");
        }
        
        // 检查用户状态
        if (user.getStatus() == 0) {
            throw new BusinessException("账号已被禁用");
        }
        
        // 更新最后登录时间
        user.setLastLoginTime(new Date());
        userMapper.updateById(user);
        
        // 生成JWT token
        return jwtUtils.generateToken(user.getId(), user.getUsername());
    }
    
    // 其他方法实现...
}

// 用户控制器
@RestController
@RequestMapping("/api/v1/auth")
public class AuthController {
    @Autowired
    private UserService userService;
    
    @PostMapping("/register")
    public ResponseResult<UserVO> register(@Validated @RequestBody UserRegisterDTO userRegisterDTO) {
        User user = userService.register(userRegisterDTO);
        return ResponseResult.success(UserVO.convert(user));
    }
    
    @PostMapping("/login")
    public ResponseResult<LoginVO> login(@Validated @RequestBody UserLoginDTO userLoginDTO) {
        String token = userService.login(userLoginDTO);
        LoginVO loginVO = new LoginVO();
        loginVO.setToken(token);
        return ResponseResult.success(loginVO);
    }
    
    @PostMapping("/logout")
    public ResponseResult<Void> logout() {
        // 登出操作，如需登出后token失效，可将token放入黑名单
        return ResponseResult.success();
    }
}
```

#### 3.1.3 流程设计

1. **用户注册流程**：
   - 接收用户注册请求
   - 参数校验
   - 检查用户名和手机号是否已存在
   - 密码加密
   - 保存用户信息
   - 返回注册结果

2. **用户登录流程**：
   - 接收用户登录请求
   - 参数校验
   - 根据用户名查询用户
   - 验证密码
   - 检查用户状态
   - 更新最后登录时间
   - 生成JWT token
   - 返回登录结果和token

### 3.2 商品模块详细设计

#### 3.2.1 接口设计

| API路径 | 方法 | 模块/文件 | 类型 | 功能描述 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/v1/categories` | `GET` | `CategoryController.java` | `Controller` | 获取商品分类列表 |
| `/api/v1/products` | `GET` | `ProductController.java` | `Controller` | 获取商品列表 |
| `/api/v1/products/{id}` | `GET` | `ProductController.java` | `Controller` | 获取商品详情 |
| `/api/v1/products/search` | `GET` | `ProductController.java` | `Controller` | 搜索商品 |

#### 3.2.2 类设计

```java
// 商品实体类
public class Product {
    private Long id;
    private String name;
    private Long categoryId;
    private BigDecimal price;
    private BigDecimal originalPrice;
    private Integer stock;
    private Integer sales;
    private String description;
    private String detail;
    private String mainImage;
    private String images;
    private Integer status;
    private Date createTime;
    private Date updateTime;
    // getter and setter
}

// 商品查询条件DTO
public class ProductQueryDTO {
    private Long categoryId;
    private String keyword;
    private Integer minPrice;
    private Integer maxPrice;
    private Integer pageNum = 1;
    private Integer pageSize = 10;
    private String sortBy = "createTime";
    private String sortOrder = "DESC";
    // getter and setter
}

// 商品服务接口
public interface ProductService {
    // 获取商品列表
    PageData<ProductVO> getProductList(ProductQueryDTO queryDTO);
    
    // 获取商品详情
    ProductDetailVO getProductDetail(Long productId);
    
    // 根据分类获取商品列表
    List<ProductVO> getProductsByCategory(Long categoryId);
    
    // 搜索商品
    PageData<ProductVO> searchProducts(ProductQueryDTO queryDTO);
    
    // 获取推荐商品
    List<ProductVO> getRecommendedProducts(Integer limit);
}

// 商品服务实现类
@Service
public class ProductServiceImpl implements ProductService {
    @Autowired
    private ProductMapper productMapper;
    
    @Override
    public PageData<ProductVO> getProductList(ProductQueryDTO queryDTO) {
        // 构建查询条件
        ProductQuery query = new ProductQuery();
        query.setCategoryId(queryDTO.getCategoryId());
        query.setKeyword(queryDTO.getKeyword());
        query.setMinPrice(queryDTO.getMinPrice());
        query.setMaxPrice(queryDTO.getMaxPrice());
        query.setSortBy(queryDTO.getSortBy());
        query.setSortOrder(queryDTO.getSortOrder());
        
        // 计算分页参数
        int offset = (queryDTO.getPageNum() - 1) * queryDTO.getPageSize();
        query.setOffset(offset);
        query.setLimit(queryDTO.getPageSize());
        
        // 查询商品列表
        List<Product> products = productMapper.selectByQuery(query);
        // 查询总数
        int total = productMapper.countByQuery(query);
        
        // 转换为VO
        List<ProductVO> productVOs = products.stream()
                .map(ProductVO::convert)
                .collect(Collectors.toList());
        
        // 返回分页数据
        return new PageData<>(productVOs, total, queryDTO.getPageNum(), queryDTO.getPageSize());
    }
    
    @Override
    public ProductDetailVO getProductDetail(Long productId) {
        // 查询商品
        Product product = productMapper.selectById(productId);
        if (product == null || product.getStatus() != 1) {
            throw new BusinessException("商品不存在或已下架");
        }
        
        // 查询商品分类
        Category category = categoryService.getCategoryById(product.getCategoryId());
        
        // 组装详情VO
        ProductDetailVO detailVO = ProductDetailVO.convert(product);
        if (category != null) {
            detailVO.setCategoryName(category.getName());
        }
        
        return detailVO;
    }
    
    // 其他方法实现...
}

// 商品控制器
@RestController
@RequestMapping("/api/v1/products")
public class ProductController {
    @Autowired
    private ProductService productService;
    
    @GetMapping
    public ResponseResult<PageData<ProductVO>> getProductList(ProductQueryDTO queryDTO) {
        PageData<ProductVO> pageData = productService.getProductList(queryDTO);
        return ResponseResult.success(pageData);
    }
    
    @GetMapping("/{id}")
    public ResponseResult<ProductDetailVO> getProductDetail(@PathVariable Long id) {
        ProductDetailVO detailVO = productService.getProductDetail(id);
        return ResponseResult.success(detailVO);
    }
    
    @GetMapping("/search")
    public ResponseResult<PageData<ProductVO>> searchProducts(ProductQueryDTO queryDTO) {
        PageData<ProductVO> pageData = productService.searchProducts(queryDTO);
        return ResponseResult.success(pageData);
    }
}
```

#### 3.2.3 流程设计

1. **获取商品列表流程**：
   - 接收查询参数
   - 构建查询条件
   - 查询商品列表
   - 查询总数
   - 转换为VO
   - 返回分页数据

2. **获取商品详情流程**：
   - 接收商品ID
   - 查询商品信息
   - 检查商品是否存在和状态
   - 查询关联数据（如分类信息）
   - 组装详情VO
   - 返回商品详情

### 3.3 购物车模块详细设计

#### 3.3.1 接口设计

| API路径 | 方法 | 模块/文件 | 类型 | 功能描述 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/v1/carts` | `GET` | `CartController.java` | `Controller` | 获取购物车列表 |
| `/api/v1/carts` | `POST` | `CartController.java` | `Controller` | 添加商品到购物车 |
| `/api/v1/carts/{id}` | `PUT` | `CartController.java` | `Controller` | 更新购物车商品数量 |
| `/api/v1/carts/{id}` | `DELETE` | `CartController.java` | `Controller` | 从购物车移除商品 |
| `/api/v1/carts` | `DELETE` | `CartController.java` | `Controller` | 清空购物车 |

#### 3.3.2 类设计

```java
// 购物车实体类
public class Cart {
    private Long id;
    private Long userId;
    private Long productId;
    private Integer quantity;
    private Integer selected;
    private Date createTime;
    private Date updateTime;
    // getter and setter
}

// 添加购物车DTO
public class AddCartDTO {
    @NotNull(message = "商品ID不能为空")
    private Long productId;
    
    @NotNull(message = "数量不能为空")
    @Min(value = 1, message = "数量不能小于1")
    private Integer quantity;
    // getter and setter
}

// 更新购物车DTO
public class UpdateCartDTO {
    @NotNull(message = "数量不能为空")
    @Min(value = 1, message = "数量不能小于1")
    private Integer quantity;
    // getter and setter
}

// 购物车服务接口
public interface CartService {
    // 获取购物车列表
    List<CartVO> getCartList(Long userId);
    
    // 添加商品到购物车
    CartVO addCart(Long userId, AddCartDTO addCartDTO);
    
    // 更新购物车商品数量
    CartVO updateCart(Long userId, Long cartId, UpdateCartDTO updateCartDTO);
    
    // 移除购物车商品
    void removeCart(Long userId, Long cartId);
    
    // 清空购物车
    void clearCart(Long userId);
    
    // 更新购物车商品选中状态
    void updateCartSelected(Long userId, Long cartId, Integer selected);
    
    // 批量更新购物车选中状态
    void batchUpdateCartSelected(Long userId, List<Long> cartIds, Integer selected);
    
    // 获取选中的购物车商品
    List<CartVO> getSelectedCarts(Long userId);
}

// 购物车服务实现类
@Service
public class CartServiceImpl implements CartService {
    @Autowired
    private CartMapper cartMapper;
    
    @Autowired
    private ProductMapper productMapper;
    
    @Override
    public CartVO addCart(Long userId, AddCartDTO addCartDTO) {
        // 检查商品是否存在
        Product product = productMapper.selectById(addCartDTO.getProductId());
        if (product == null || product.getStatus() != 1) {
            throw new BusinessException("商品不存在或已下架");
        }
        
        // 检查库存
        if (product.getStock() < addCartDTO.getQuantity()) {
            throw new BusinessException("商品库存不足");
        }
        
        // 查询购物车中是否已有该商品
        Cart cart = cartMapper.selectByUserIdAndProductId(userId, addCartDTO.getProductId());
        
        if (cart != null) {
            // 已存在，更新数量
            cart.setQuantity(cart.getQuantity() + addCartDTO.getQuantity());
            // 检查更新后的数量是否超过库存
            if (cart.getQuantity() > product.getStock()) {
                throw new BusinessException("商品库存不足");
            }
            cartMapper.updateById(cart);
        } else {
            // 不存在，添加新记录
            cart = new Cart();
            cart.setUserId(userId);
            cart.setProductId(addCartDTO.getProductId());
            cart.setQuantity(addCartDTO.getQuantity());
            cart.setSelected(1); // 默认选中
            cartMapper.insert(cart);
        }
        
        // 返回购物车VO
        return getCartVO(cart);
    }
    
    @Override
    public List<CartVO> getCartList(Long userId) {
        // 查询用户的购物车列表
        List<Cart> carts = cartMapper.selectByUserId(userId);
        
        // 转换为VO
        return carts.stream()
                .map(this::getCartVO)
                .collect(Collectors.toList());
    }
    
    // 转换购物车为VO
    private CartVO getCartVO(Cart cart) {
        Product product = productMapper.selectById(cart.getProductId());
        if (product == null) {
            return null;
        }
        
        CartVO cartVO = new CartVO();
        cartVO.setId(cart.getId());
        cartVO.setProductId(cart.getProductId());
        cartVO.setProductName(product.getName());
        cartVO.setMainImage(product.getMainImage());
        cartVO.setPrice(product.getPrice());
        cartVO.setStock(product.getStock());
        cartVO.setQuantity(cart.getQuantity());
        cartVO.setSelected(cart.getSelected());
        
        return cartVO;
    }
    
    // 其他方法实现...
}

// 购物车控制器
@RestController
@RequestMapping("/api/v1/carts")
public class CartController {
    @Autowired
    private CartService cartService;
    
    @GetMapping
    public ResponseResult<List<CartVO>> getCartList(@CurrentUser User currentUser) {
        List<CartVO> cartList = cartService.getCartList(currentUser.getId());
        return ResponseResult.success(cartList);
    }
    
    @PostMapping
    public ResponseResult<CartVO> addCart(@CurrentUser User currentUser, 
                                         @Validated @RequestBody AddCartDTO addCartDTO) {
        CartVO cartVO = cartService.addCart(currentUser.getId(), addCartDTO);
        return ResponseResult.success(cartVO);
    }
    
    @PutMapping("/{id}")
    public ResponseResult<CartVO> updateCart(@CurrentUser User currentUser, 
                                           @PathVariable Long id,
                                           @Validated @RequestBody UpdateCartDTO updateCartDTO) {
        CartVO cartVO = cartService.updateCart(currentUser.getId(), id, updateCartDTO);
        return ResponseResult.success(cartVO);
    }
    
    @DeleteMapping("/{id}")
    public ResponseResult<Void> removeCart(@CurrentUser User currentUser, @PathVariable Long id) {
        cartService.removeCart(currentUser.getId(), id);
        return ResponseResult.success();
    }
    
    @DeleteMapping
    public ResponseResult<Void> clearCart(@CurrentUser User currentUser) {
        cartService.clearCart(currentUser.getId());
        return ResponseResult.success();
    }
}
```

### 3.4 订单模块详细设计

#### 3.4.1 接口设计

| API路径 | 方法 | 模块/文件 | 类型 | 功能描述 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/v1/orders` | `POST` | `OrderController.java` | `Controller` | 创建订单 |
| `/api/v1/orders` | `GET` | `OrderController.java` | `Controller` | 获取订单列表 |
| `/api/v1/orders/{id}` | `GET` | `OrderController.java` | `Controller` | 获取订单详情 |
| `/api/v1/orders/{id}/cancel` | `PUT` | `OrderController.java` | `Controller` | 取消订单 |
| `/api/v1/orders/{id}/confirm` | `PUT` | `OrderController.java` | `Controller` | 确认收货 |

#### 3.4.2 类设计

```java
// 订单实体类
public class Order {
    private Long id;
    private String orderNo;
    private Long userId;
    private BigDecimal totalAmount;
    private BigDecimal actualPay;
    private Integer status;
    private Integer paymentType;
    private String paymentNo;
    private String consignee;
    private String phone;
    private String province;
    private String city;
    private String district;
    private String detailAddress;
    private String remark;
    private Date paymentTime;
    private Date deliveryTime;
    private Date receiveTime;
    private Date cancelTime;
    private Date createTime;
    private Date updateTime;
    // getter and setter
}

// 订单项实体类
public class OrderItem {
    private Long id;
    private Long orderId;
    private Long productId;
    private String productName;
    private String productImage;
    private BigDecimal unitPrice;
    private Integer quantity;
    private BigDecimal totalPrice;
    private Date createTime;
    private Date updateTime;
    // getter and setter
}

// 创建订单DTO
public class CreateOrderDTO {
    @NotNull(message = "收货地址ID不能为空")
    private Long addressId;
    
    private List<Long> cartIds;
    
    private String remark;
    // getter and setter
}

// 订单服务接口
public interface OrderService {
    // 创建订单
    OrderVO createOrder(Long userId, CreateOrderDTO createOrderDTO);
    
    // 获取订单列表
    PageData<OrderListVO> getOrderList(Long userId, Integer status, Integer pageNum, Integer pageSize);
    
    // 获取订单详情
    OrderDetailVO getOrderDetail(Long userId, Long orderId);
    
    // 取消订单
    void cancelOrder(Long userId, Long orderId);
    
    // 确认收货
    void confirmOrder(Long userId, Long orderId);
    
    // 根据订单号查询订单
    Order getOrderByOrderNo(String orderNo);
    
    // 更新订单状态
    void updateOrderStatus(Long orderId, Integer status);
}

// 订单服务实现类
@Service
public class OrderServiceImpl implements OrderService {
    @Autowired
    private OrderMapper orderMapper;
    
    @Autowired
    private OrderItemMapper orderItemMapper;
    
    @Autowired
    private ProductMapper productMapper;
    
    @Autowired
    private CartMapper cartMapper;
    
    @Autowired
    private AddressMapper addressMapper;
    
    @Autowired
    private IdGenerator idGenerator;
    
    @Override
    @Transactional(rollbackFor = Exception.class)
    public OrderVO createOrder(Long userId, CreateOrderDTO createOrderDTO) {
        // 查询收货地址
        Address address = addressMapper.selectById(createOrderDTO.getAddressId());
        if (address == null || !address.getUserId().equals(userId)) {
            throw new BusinessException("收货地址不存在");
        }
        
        // 查询购物车商品
        List<Cart> carts = cartMapper.selectByIdsAndUserId(createOrderDTO.getCartIds(), userId);
        if (carts.isEmpty()) {
            throw new BusinessException("购物车商品不存在");
        }
        
        // 检查商品库存并计算总金额
        BigDecimal totalAmount = BigDecimal.ZERO;
        List<OrderItem> orderItems = new ArrayList<>();
        
        for (Cart cart : carts) {
            Product product = productMapper.selectById(cart.getProductId());
            if (product == null || product.getStatus() != 1) {
                throw new BusinessException("商品" + product.getName() + "不存在或已下架");
            }
            
            if (product.getStock() < cart.getQuantity()) {
                throw new BusinessException("商品" + product.getName() + "库存不足");
            }
            
            // 计算小计
            BigDecimal itemTotal = product.getPrice().multiply(new BigDecimal(cart.getQuantity()));
            totalAmount = totalAmount.add(itemTotal);
            
            // 创建订单项
            OrderItem orderItem = new OrderItem();
            orderItem.setProductId(product.getId());
            orderItem.setProductName(product.getName());
            orderItem.setProductImage(product.getMainImage());
            orderItem.setUnitPrice(product.getPrice());
            orderItem.setQuantity(cart.getQuantity());
            orderItem.setTotalPrice(itemTotal);
            orderItems.add(orderItem);
            
            // 扣减库存
            product.setStock(product.getStock() - cart.getQuantity());
            product.setSales(product.getSales() + cart.getQuantity());
            productMapper.updateById(product);
        }
        
        // 创建订单
        Order order = new Order();
        order.setOrderNo(idGenerator.generateOrderNo());
        order.setUserId(userId);
        order.setTotalAmount(totalAmount);
        order.setActualPay(totalAmount); // 暂不考虑优惠
        order.setStatus(0); // 待支付
        order.setConsignee(address.getConsignee());
        order.setPhone(address.getPhone());
        order.setProvince(address.getProvince());
        order.setCity(address.getCity());
        order.setDistrict(address.getDistrict());
        order.setDetailAddress(address.getDetailAddress());
        order.setRemark(createOrderDTO.getRemark());
        
        // 保存订单
        orderMapper.insert(order);
        
        // 保存订单项
        for (OrderItem orderItem : orderItems) {
            orderItem.setOrderId(order.getId());
            orderItemMapper.insert(orderItem);
        }
        
        // 清空购物车中已购买的商品
        cartMapper.deleteByIds(createOrderDTO.getCartIds());
        
        // 返回订单VO
        OrderVO orderVO = new OrderVO();
        orderVO.setOrderNo(order.getOrderNo());
        orderVO.setTotalAmount(order.getTotalAmount());
        
        return orderVO;
    }
    
    // 其他方法实现...
}

// 订单控制器
@RestController
@RequestMapping("/api/v1/orders")
public class OrderController {
    @Autowired
    private OrderService orderService;
    
    @PostMapping
    public ResponseResult<OrderVO> createOrder(@CurrentUser User currentUser, 
                                             @Validated @RequestBody CreateOrderDTO createOrderDTO) {
        OrderVO orderVO = orderService.createOrder(currentUser.getId(), createOrderDTO);
        return ResponseResult.success(orderVO);
    }
    
    @GetMapping
    public ResponseResult<PageData<OrderListVO>> getOrderList(@CurrentUser User currentUser, 
                                                            Integer status,
                                                            @RequestParam(defaultValue = "1") Integer pageNum,
                                                            @RequestParam(defaultValue = "10") Integer pageSize) {
        PageData<OrderListVO> pageData = orderService.getOrderList(currentUser.getId(), status, pageNum, pageSize);
        return ResponseResult.success(pageData);
    }
    
    @GetMapping("/{id}")
    public ResponseResult<OrderDetailVO> getOrderDetail(@CurrentUser User currentUser, @PathVariable Long id) {
        OrderDetailVO detailVO = orderService.getOrderDetail(currentUser.getId(), id);
        return ResponseResult.success(detailVO);
    }
    
    @PutMapping("/{id}/cancel")
    public ResponseResult<Void> cancelOrder(@CurrentUser User currentUser, @PathVariable Long id) {
        orderService.cancelOrder(currentUser.getId(), id);
        return ResponseResult.success();
    }
    
    @PutMapping("/{id}/confirm")
    public ResponseResult<Void> confirmOrder(@CurrentUser User currentUser, @PathVariable Long id) {
        orderService.confirmOrder(currentUser.getId(), id);
        return ResponseResult.success();
    }
}
```

### 3.5 管理员模块详细设计

#### 3.5.1 接口设计

| API路径 | 方法 | 模块/文件 | 类型 | 功能描述 |
| :--- | :--- | :--- | :--- | :--- |
| `/api/v1/admin/auth/login` | `POST` | `AdminController.java` | `Controller` | 管理员登录 |
| `/api/v1/admin/users` | `GET` | `AdminController.java` | `Controller` | 获取用户列表 |
| `/api/v1/admin/users/{id}/status` | `PUT` | `AdminController.java` | `Controller` | 修改用户状态 |
| `/api/v1/admin/products` | `GET` | `AdminController.java` | `Controller` | 获取商品列表 |
| `/api/v1/admin/products` | `POST` | `AdminController.java` | `Controller` | 添加商品 |
| `/api/v1/admin/products/{id}` | `PUT` | `AdminController.java` | `Controller` | 更新商品 |
| `/api/v1/admin/products/{id}` | `DELETE` | `AdminController.java` | `Controller` | 删除商品 |
| `/api/v1/admin/orders` | `GET` | `AdminController.java` | `Controller` | 获取订单列表 |
| `/api/v1/admin/orders/{id}/status` | `PUT` | `AdminController.java` | `Controller` | 修改订单状态 |

#### 3.5.2 类设计

```java
// 管理员实体类
public class Admin {
    private Long id;
    private String username;
    private String password;
    private String name;
    private String phone;
    private String email;
    private Long roleId;
    private Integer status;
    private Date createTime;
    private Date updateTime;
    private Date lastLoginTime;
    // getter and setter
}

// 管理员登录DTO
public class AdminLoginDTO {
    @NotBlank(message = "用户名不能为空")
    private String username;
    
    @NotBlank(message = "密码不能为空")
    private String password;
    // getter and setter
}

// 管理员服务接口
public interface AdminService {
    // 管理员登录
    String login(AdminLoginDTO loginDTO);
    
    // 获取管理员信息
    Admin getAdminById(Long adminId);
    
    // 修改管理员密码
    void updatePassword(Long adminId, String oldPassword, String newPassword);
}

// 管理员服务实现类
@Service
public class AdminServiceImpl implements AdminService {
    @Autowired
    private AdminMapper adminMapper;
    
    @Autowired
    private PasswordUtils passwordUtils;
    
    @Autowired
    private JwtUtils jwtUtils;
    
    @Override
    public String login(AdminLoginDTO loginDTO) {
        // 根据用户名查询管理员
        Admin admin = adminMapper.selectByUsername(loginDTO.getUsername());
        if (admin == null) {
            throw new BusinessException("用户名或密码错误");
        }
        
        // 检查密码是否正确
        if (!passwordUtils.matches(loginDTO.getPassword(), admin.getPassword())) {
            throw new BusinessException("用户名或密码错误");
        }
        
        // 检查状态
        if (admin.getStatus() == 0) {
            throw new BusinessException("账号已被禁用");
        }
        
        // 更新最后登录时间
        admin.setLastLoginTime(new Date());
        adminMapper.updateById(admin);
        
        // 生成JWT token
        return jwtUtils.generateAdminToken(admin.getId(), admin.getUsername());
    }
    
    // 其他方法实现...
}

// 管理员控制器
@RestController
@RequestMapping("/api/v1/admin/auth")
public class AdminAuthController {
    @Autowired
    private AdminService adminService;
    
    @PostMapping("/login")
    public ResponseResult<LoginVO> login(@Validated @RequestBody AdminLoginDTO loginDTO) {
        String token = adminService.login(loginDTO);
        LoginVO loginVO = new LoginVO();
        loginVO.setToken(token);
        return ResponseResult.success(loginVO);
    }
}

// 管理员用户管理控制器
@RestController
@RequestMapping("/api/v1/admin/users")
public class AdminUserController {
    @Autowired
    private UserService userService;
    
    @GetMapping
    public ResponseResult<PageData<UserListVO>> getUserList(UserQueryDTO queryDTO) {
        PageData<UserListVO> pageData = userService.getUserList(queryDTO);
        return ResponseResult.success(pageData);
    }
    
    @PutMapping("/{id}/status")
    public ResponseResult<Void> updateUserStatus(@PathVariable Long id, @RequestParam Integer status) {
        userService.updateUserStatus(id, status);
        return ResponseResult.success();
    }
}

// 管理员商品管理控制器
@RestController
@RequestMapping("/api/v1/admin/products")
public class AdminProductController {
    @Autowired
    private ProductService productService;
    
    @GetMapping
    public ResponseResult<PageData<ProductListVO>> getProductList(ProductQueryDTO queryDTO) {
        PageData<ProductListVO> pageData = productService.getProductList(queryDTO);
        return ResponseResult.success(pageData);
    }
    
    @PostMapping
    public ResponseResult<ProductVO> addProduct(@Validated @RequestBody AddProductDTO addProductDTO) {
        ProductVO productVO = productService.addProduct(addProductDTO);
        return ResponseResult.success(productVO);
    }
    
    @PutMapping("/{id}")
    public ResponseResult<ProductVO> updateProduct(@PathVariable Long id, 
                                                 @Validated @RequestBody UpdateProductDTO updateProductDTO) {
        ProductVO productVO = productService.updateProduct(id, updateProductDTO);
        return ResponseResult.success(productVO);
    }
    
    @DeleteMapping("/{id}")
    public ResponseResult<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseResult.success();
    }
}
```

## 4. 安全设计

### 4.1 认证与授权设计

#### 4.1.1 JWT配置

```java
@Configuration
public class JwtConfig {
    @Value("${jwt.secret}")
    private String secret;
    
    @Value("${jwt.expiration}")
    private Long expiration;
    
    @Bean
    public JwtUtils jwtUtils() {
        return new JwtUtils(secret, expiration);
    }
}

@Component
public class JwtUtils {
    private String secret;
    private Long expiration;
    
    public JwtUtils(String secret, Long expiration) {
        this.secret = secret;
        this.expiration = expiration;
    }
    
    // 生成用户token
    public String generateToken(Long userId, String username) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("userId", userId);
        claims.put("username", username);
        claims.put("type", "user");
        
        return generateToken(claims);
    }
    
    // 生成管理员token
    public String generateAdminToken(Long adminId, String username) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("adminId", adminId);
        claims.put("username", username);
        claims.put("type", "admin");
        
        return generateToken(claims);
    }
    
    // 生成token
    private String generateToken(Map<String, Object> claims) {
        Date now = new Date();
        Date expirationDate = new Date(now.getTime() + expiration * 1000);
        
        return Jwts.builder()
                .setClaims(claims)
                .setIssuedAt(now)
                .setExpiration(expirationDate)
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }
    
    // 解析token
    public Claims parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody();
    }
    
    // 验证token是否过期
    public boolean isTokenExpired(String token) {
        try {
            Claims claims = parseToken(token);
            Date expiration = claims.getExpiration();
            return expiration.before(new Date());
        } catch (Exception e) {
            return true;
        }
    }
}
```

#### 4.1.2 Spring Security配置

```java
@Configuration
@EnableWebSecurity
public class SecurityConfig extends WebSecurityConfigurerAdapter {
    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Autowired
    private AuthAccessDeniedHandler accessDeniedHandler;
    
    @Autowired
    private AuthEntryPointUnauthorizedHandler authenticationEntryPoint;
    
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http
            // 禁用CSRF
            .csrf().disable()
            // 禁用Session
            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
            // 授权配置
            .authorizeRequests()
                // 允许匿名访问的路径
                .antMatchers("/api/v1/auth/login", "/api/v1/auth/register", "/api/v1/categories", 
                             "/api/v1/products", "/api/v1/products/**", "/api/v1/products/search", 
                             "/api/v1/admin/auth/login", "/swagger-ui/**", "/v3/api-docs/**").permitAll()
                // 需要管理员权限的路径
                .antMatchers("/api/v1/admin/**").hasRole("ADMIN")
                // 其他所有请求都需要认证
                .anyRequest().authenticated()
                .and()
            // 添加JWT过滤器
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            // 异常处理
            .exceptionHandling()
                .accessDeniedHandler(accessDeniedHandler)
                .authenticationEntryPoint(authenticationEntryPoint)
                .and()
            // 跨域配置
            .cors().and()
            // 其他配置
            .headers().cacheControl();
    }
    
    @Override
    protected void configure(AuthenticationManagerBuilder auth) throws Exception {
        // 配置认证管理器
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    @Override
    public AuthenticationManager authenticationManagerBean() throws Exception {
        return super.authenticationManagerBean();
    }
}
```

#### 4.1.3 JWT认证过滤器

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    @Autowired
    private JwtUtils jwtUtils;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private AdminService adminService;
    
    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) 
            throws ServletException, IOException {
        String token = getTokenFromRequest(request);
        
        if (token != null && !jwtUtils.isTokenExpired(token)) {
            try {
                Claims claims = jwtUtils.parseToken(token);
                String type = (String) claims.get("type");
                
                if ("user".equals(type)) {
                    // 用户认证
                    Long userId = Long.parseLong(claims.get("userId").toString());
                    User user = userService.getUserById(userId);
                    if (user != null && user.getStatus() == 1) {
                        // 创建认证对象
                        UsernamePasswordAuthenticationToken authentication = 
                            new UsernamePasswordAuthenticationToken(user, null, Collections.emptyList());
                        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        
                        // 设置认证信息到上下文
                        SecurityContextHolder.getContext().setAuthentication(authentication);
                    }
                } else if ("admin".equals(type)) {
                    // 管理员认证
                    Long adminId = Long.parseLong(claims.get("adminId").toString());
                    Admin admin = adminService.getAdminById(adminId);
                    if (admin != null && admin.getStatus() == 1) {
                        // 创建认证对象
                        UsernamePasswordAuthenticationToken authentication = 
                            new UsernamePasswordAuthenticationToken(admin, null, 
                                Collections.singletonList(new SimpleGrantedAuthority("ROLE_ADMIN")));
                        authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                        
                        // 设置认证信息到上下文
                        SecurityContextHolder.getContext().setAuthentication(authentication);
                    }
                }
            } catch (Exception e) {
                // 认证失败，清除认证信息
                SecurityContextHolder.clearContext();
            }
        }
        
        filterChain.doFilter(request, response);
    }
    
    // 从请求头中获取token
    private String getTokenFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader("Authorization");
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith("Bearer ")) {
            return bearerToken.substring(7);
        }
        return null;
    }
}
```

### 4.2 全局CORS配置

```java
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOriginPatterns("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .exposedHeaders("Content-Disposition")
                .allowCredentials(true)
                .maxAge(3600);
    }
}
```

### 4.3 密码加密工具

```java
@Component
public class PasswordUtils {
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    // 加密密码
    public String encode(String rawPassword) {
        return passwordEncoder.encode(rawPassword);
    }
    
    // 验证密码
    public boolean matches(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }
}
```

### 4.4 异常处理

```java
// 自定义业务异常
public class BusinessException extends RuntimeException {
    private Integer code;
    
    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }
    
    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }
    
    public Integer getCode() {
        return code;
    }
}

// 全局异常处理
@RestControllerAdvice
public class GlobalExceptionHandler {
    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);
    
    // 处理业务异常
    @ExceptionHandler(BusinessException.class)
    public ResponseResult<Void> handleBusinessException(BusinessException e) {
        logger.error("业务异常: {}", e.getMessage(), e);
        return ResponseResult.fail(e.getCode(), e.getMessage());
    }
    
    // 处理参数校验异常
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseResult<Void> handleValidationException(MethodArgumentNotValidException e) {
        BindingResult bindingResult = e.getBindingResult();
        String errorMessage = bindingResult.getFieldError().getDefaultMessage();
        logger.error("参数校验异常: {}", errorMessage, e);
        return ResponseResult.fail(400, errorMessage);
    }
    
    // 处理其他异常
    @ExceptionHandler(Exception.class)
    public ResponseResult<Void> handleException(Exception e) {
        logger.error("系统异常: {}", e.getMessage(), e);
        return ResponseResult.fail(500, "系统内部错误");
    }
}
```

## 5. 部署架构设计

### 5.1 Docker Compose配置

```yaml
# docker-compose.yml
version: '3'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: shopping-mysql
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: shopping
      MYSQL_USER: shopping
      MYSQL_PASSWORD: shopping
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./mysql/init:/docker-entrypoint-initdb.d
    networks:
      - shopping-network

  # Redis缓存
  redis:
    image: redis:6.2
    container_name: shopping-redis
    restart: always
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    networks:
      - shopping-network

  # 后端应用
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: shopping-backend
    restart: always
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/shopping?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: shopping
      SPRING_DATASOURCE_PASSWORD: shopping
      SPRING_REDIS_HOST: redis
    networks:
      - shopping-network

  # Nginx
  nginx:
    image: nginx:1.21
    container_name: shopping-nginx
    restart: always
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx/conf/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/html:/usr/share/nginx/html
      - ./nginx/logs:/var/log/nginx
    depends_on:
      - backend
    networks:
      - shopping-network

volumes:
  mysql-data:
  redis-data:

networks:
  shopping-network:
    driver: bridge
```

### 5.2 Dockerfile配置

```dockerfile
# 后端Dockerfile
FROM openjdk:11-jre-slim

WORKDIR /app

COPY target/shopping-backend.jar /app/app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

### 5.3 Nginx配置

```nginx
# nginx.conf
user nginx;
worker_processes auto;

error_log /var/log/nginx/error.log warn;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;

    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log /var/log/nginx/access.log main;

    sendfile on;
    #tcp_nopush on;

    keepalive_timeout 65;

    #gzip on;

    # 前端静态资源
    server {
        listen 80;
        server_name localhost;

        # 前端资源目录
        location / {
            root /usr/share/nginx/html;
            index index.html index.htm;
            try_files $uri $uri/ /index.html;
        }

        # API代理
        location /api {
            proxy_pass http://backend:8080/api;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
        }

        # 文件上传代理
        location /upload {
            proxy_pass http://backend:8080/upload;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root /usr/share/nginx/html;
        }
    }
}
```

## 6. 性能优化

### 6.1 前端性能优化

1. **资源压缩和缓存**
   - 使用Vite进行代码压缩和分割
   - 配置合理的缓存策略
   - 使用CDN加速静态资源

2. **懒加载**
   - 路由懒加载
   - 组件懒加载
   - 图片懒加载

3. **按需加载**
   - Element Plus组件按需引入
   - 第三方库按需引入

4. **响应式数据优化**
   - 避免不必要的响应式属性
   - 使用computed和watch优化数据响应

### 6.2 后端性能优化

1. **数据库优化**
   - 合理设计索引
   - 优化SQL查询
   - 使用连接池管理数据库连接

2. **缓存优化**
   - 使用Redis缓存热点数据
   - 缓存用户会话信息
   - 缓存商品列表和详情

3. **代码优化**
   - 使用Stream API优化集合操作
   - 避免重复计算
   - 优化循环和条件判断

4. **异步处理**
   - 使用异步方法处理耗时操作
   - 使用消息队列处理异步任务

### 6.3 系统优化

1. **负载均衡**
   - 使用Nginx实现负载均衡
   - 水平扩展应用服务器

2. **数据库主从复制**
   - 实现读写分离
   - 提高数据库并发性能

3. **定时任务优化**
   - 合理设置定时任务执行时间
   - 避免任务堆积

4. **监控和日志**
   - 配置应用监控
   - 优化日志记录
   - 定期分析系统性能

## 7. 测试计划

### 7.1 单元测试

使用JUnit和Mockito进行单元测试，主要测试以下内容：

1. **Service层测试**：测试业务逻辑的正确性
2. **Mapper层测试**：测试数据库操作
3. **工具类测试**：测试工具方法的正确性

### 7.2 集成测试

使用Spring Boot Test进行集成测试，主要测试以下内容：

1. **API接口测试**：测试API的正确性和异常处理
2. **数据库集成测试**：测试数据持久化和事务处理
3. **安全测试**：测试认证和授权机制

### 7.3 端到端测试

使用Selenium或Cypress进行端到端测试，主要测试以下内容：

1. **用户流程测试**：测试用户注册、登录、购物流程
2. **管理员流程测试**：测试管理员功能
3. **兼容性测试**：测试不同浏览器和设备

## 8. 附录

### 8.1 相关配置

#### 8.1.1 应用配置（application.yml）

```yaml
server:
  port: 8080
  servlet:
    context-path: /

spring:
  datasource:
    url: jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  redis:
    host: localhost
    port: 6379
    password: 
    database: 0
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 100MB

mybatis:
  mapper-locations: classpath:mapper/**/*.xml
  type-aliases-package: com.shopping.*.entity
  configuration:
    map-underscore-to-camel-case: true

jwt:
  secret: your-secret-key
  expiration: 3600

logging:
  level:
    root: info
    com.shopping: debug
  file:
    name: logs/shopping.log

# 文件上传配置
file:
  upload-dir: /upload
  max-size: 10MB
```

### 8.2 开发环境配置

1. **JDK 11或更高版本**
2. **MySQL 8.0**
3. **Redis 6.0+**
4. **Maven 3.6+**
5. **Node.js 14+**
6. **Vue CLI 5+**
7. **Docker和Docker Compose**

### 8.3 参考资料

- [Spring Boot官方文档](https://spring.io/guides/gs/spring-boot)
- [MyBatis官方文档](https://mybatis.org/mybatis-3/zh/index.html)
- [Vue.js官方文档](https://v3.vuejs.org/guide/introduction.html)
- [Element Plus官方文档](https://element-plus.gitee.io/zh-CN/)
- [Docker官方文档](https://docs.docker.com/)
- [Nginx官方文档](http://nginx.org/en/docs/)
- [JWT官方文档](https://jwt.io/introduction/)